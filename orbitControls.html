<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>model</title>
  </head>
  <!-- стили -->
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    .container {
      width: 100vw;
      height: 100vh;
    }
  </style>
  <body>
    <!-- контейнер для обьекта -->
    <div class="container"></div>

    <!-- библиотека threejs -->
    <script src="build/three.min.js"></script>

    <!-- основной код модели -->
    <script type="module">
      // импорт нужных библиотек
      import { OrbitControls } from "./examples/jsm/controls/OrbitControls.js"
      import { GLTFLoader } from "./examples/jsm/loaders/GLTFLoader.js"
      import { SkeletonUtils } from "./examples/jsm/utils/SkeletonUtils.js"

      let scene
      let camera
      let renderer
      const mixers = []
      const clock = new THREE.Clock()

      function init() {
        let container = document.querySelector(".container")

        scene = new THREE.Scene()
        scene.background = new THREE.Color("#bbb")
        const ground = new THREE.Mesh(
          new THREE.PlaneGeometry(800, 800),
          new THREE.MeshLambertMaterial({ color: "rgb(240,240,240)" })
        )
        ground.rotation.x = -Math.PI / 2
        ground.receiveShadow = true
        scene.add(ground)

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000)

        camera.position.z = 140
        camera.position.y = 100
        camera.position.x = 200

        renderer = new THREE.WebGLRenderer({})
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMap.enabled = true
        container.appendChild(renderer.domElement)

        /*
         *
         */
        //управление орбитой - позволяем камере вращаться вокруг обьекта
        /*
        OrbitControls(object : Camera, domElement : HTMLDOMElement )
          object — обязательно камера
          domElement — элемент HTML, используемый для прослушивателей событий
        */
        const controls = new OrbitControls(camera, renderer.domElement)
        //При прекращении поворота элемента присутствует плавность. Установите true, чтобы включить.
        controls.enableDamping = true
        //настройка плавности (enableDamping = true - обязательно) от 0 до 1
        controls.dampingFactor = 0.08
        //смешение центра точки
        controls.target.set(0, 40, 0)
        //минимальная дистанция приближения
        controls.minDistance = 100
        //максимальная дистанция приближения
        controls.maxDistance = 600
        //минимальный угол наклона дистанции от 0 до Math.PI (0 - самый верх)
        controls.minPolarAngle = 0
        //максимальный угол наклона дистанции от 0 до Math.PI (Math.PI - самый низ)
        controls.maxPolarAngle = Math.PI * 0.52
        //автоповорот
        //controls.autoRotate = true
        //скорость автоповорота
        //controls.autoRotateSpeed = -1
        //возможность управлять на стрелки
        controls.listenToKeyEvents(window)
        //настройка клавишь (по стандарту)
        controls.keys = {
          LEFT: "ArrowLeft",
          UP: "ArrowUp",
          RIGHT: "ArrowRight",
          BOTTOM: "ArrowDown",
        }
        //скорость управления клавишами (по стандарту 7)
        controls.keyPanSpeed = 10
        //как управляется камера true - относительно экрана, false - относительно плоскости
        controls.screenSpacePanning = false
        //настройки для мыши, ROTATE - поворот, DOLLY - дистанция, PAN - положение
        controls.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.PAN,
        }
        // скорость изменения поворота
        controls.rotateSpeed = 1
        // скорость изменения дистанция
        controls.zoomSpeed = 1
        // скорость изменения положения
        controls.panSpeed = 1

        //обновляем элемент управления. Должно быть вызван после любых ручных изменений в трансформации камеры если есть .autoRotate или .enableDamping
        controls.update()
        //выводим все свойства OrbitControls
        console.dir(controls)

        const ambient = new THREE.AmbientLight(0xffffff, 0.25)
        scene.add(ambient)

        const dirLight = new THREE.DirectionalLight("rgb(255,234,229)", 1)
        dirLight.position.set(1000, 2000, 1000)
        scene.add(dirLight)
        dirLight.castShadow = true
        dirLight.shadow.mapSize.width = 2048
        dirLight.shadow.mapSize.height = 2048
        dirLight.shadow.camera.near = 0.5
        dirLight.shadow.camera.far = 5000
        const d = 500
        dirLight.shadow.camera.left = -d
        dirLight.shadow.camera.right = d
        dirLight.shadow.camera.top = d
        dirLight.shadow.camera.bottom = -d
        /*
        const dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10)
        scene.add(dirLightHelper)
        */

        const loader = new GLTFLoader()
        loader.load(
          "model/gltf/Fox.glb",
          gltf => {
            gltf.scene.traverse(function (object) {
              if (object.isMesh) object.castShadow = true
            })
            const model1 = SkeletonUtils.clone(gltf.scene)
            model1.position.x = 0
            model1.position.y = 0
            /*
            document.addEventListener("keydown", onDocumentKeyDown, false)
            function onDocumentKeyDown(event) {
              var keyCode = event.which
              console.log(event)
              console.log(event.which)
              if (keyCode == 38) {
                model1.position.z += 10
              } else if (keyCode == 40) {
                model1.position.z -= 10
              } else if (keyCode == 37) {
                model1.rotation.y += Math.PI / 90
              } else if (keyCode == 39) {
                model1.rotation.y -= Math.PI / 90
              }
            }
*/
            scene.add(model1)

            const mixer1 = new THREE.AnimationMixer(model1)
            mixer1.clipAction(gltf.animations[0]).play()

            mixers.push(mixer1)
          },
          undefined,
          function (error) {
            console.log("Error: " + error)
          }
        )

        window.addEventListener("resize", onWindowResize)
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()
          renderer.setSize(window.innerWidth, window.innerHeight)
        }

        function animate() {
          requestAnimationFrame(animate)
          //необходим для работы с OrbitControls
          controls.update()

          const delta = clock.getDelta()
          for (const mixer of mixers) mixer.update(delta)

          renderer.render(scene, camera)
        }
        animate()
      }
      init()
    </script>

    <script>
      // movement - please calibrate these values
    </script>
  </body>
</html>
